# Project Plan: PromptToSoftware Frontend Development

This document outlines a complete and self-contained project plan for the development of the PromptToSoftware frontend web application. It captures all details from the original user request, enhances them with production-grade best practices, and specifies a comprehensive implementation and testing strategy, tailored to the given development environment constraints.

---

## 1. Project Overview & Original Requirements

### Complete User Request:
```
**Important note: You are to make the frontend only. The backend will be developed separately. Details included here for clarity. If the backend doesn’t give information the front end needs, it should be assumed the backend will be changed to accommodate the front end.**

**Frontend website design plan**
prompttosoftware.com

***About***
PromptToSoftware is a website that uses AI agents to build software based on user requests. User’s can make multiple requests, each one worked on by a separate team of agents. The agents do not communicate with the user (except for user information requests), once the request is made, the team works until it is completed. However, the user can continue to send messages while the project is active. The agents push their changes directly to the user’s GitHub. When the project is completed, the user will be sent a firebase notification, if allowed. A project is completed when the agents stops working and signal completion (handled by the backend)

***Payments***
Stripe
Users can add an amount to their account at any time.
Current balance should display.

***Account creation and sign in***
Github OAuth

***Data storage (Backend)***
Mongodb
User information – payment information, current balance, saved card,
Usage information – requests – request Id, prompt, github repository url, status

***Theme***
Minimalist, white, black, gray
Stripe UI components

***Website pages***
Create project
Project details
Explore projects
Projects
Help
Settings
Sign in

***Persistent elements***
Side nav bar –
When expanded -> collapse button, home/dashboard button, new project button, projects button with live project icon, explore button, help button at bottom.
When collapsed -> Expand button, new project button with just the icon, help button icon at bottom
Tooltips on hover for each collapsed button

*Profile and balance buttons*
Profile button –
Circle with profile icon
When clicked -> pop up modal with settings button and logout button.

Balance –
Square with text of the users current account balance which is a currency amount

Add payment button –
Square button with + icon.
When clicked -> it opens payment modal for entering payment information and amount.

Watch ad button –
Google Adsense
When clicked -> ad plays, amount of funds added to user’s account.
On hover -> Tooltip with text explaining that watching an ad adds funds to account.

Page title –
Aligned at the top, next to the side nav bar, moves with it to stay visible.

***Pop Ups***
Error –
Modal that appears in the top center of the screen. Has a close button and displays an error message. Should be in plain english and determined by the responses from the backend. Closes automatically after a set amount of time.

Payment modal –
Amount input field, the Stripe Elements container (for secure card input), a confirmation button, and an area to display errors from Stripe.js or the create-intent API call.

Sensitive information request –
Displays: (based on the pendingSensitiveRequest field in the GET /projects/{projectId} or /status response).

API Interaction: Ensure the frontend is prepared to poll the status/details endpoint and update the UI when pendingSensitiveRequest is not null, and subsequently call POST /projects/{projectId}/response-sensitive with the correct requestId and user input.

Project name
Information request
Reason for request
Secure masked text field for information
Reject button
Submit button

***Dashboard***
Central hub
Active projects with basic information –
Repositories, cost to date, total runtime, progress
View all button that goes to projects page
Account wide usage information –
Graph with spending information (current month my default, option to switch to previous months)
Percent current month total compared to previous month total to the current day
Estimated time until current budget runs out based on active projects average cost
Warning if budget will likely run out before projects finish
Add funds button

***Help Page***
Vertical list of buttons aligned to the left.
About –
Information about the company and the website
GitHub –
Explanation of how GitHub is used, what GitHub is, basic explanation of cloning repositories, and where to learn more
Jira –
Same as GitHub but for Jira
Addons –
Explanation of the different addons available (android, Unity, etc.) and how and why they affect project cost (i.e. they require separate docker containers to handle the heavy load of running those kinds of applications
Billing –
Explanation of how project cost is calculated, when money is taken out of the users account, and how watching ads adds funds to their account.

***Explore Page***
Search bar at top center –
Enter text and filter projects that contain the text

Vertically scrolling grid layout.
Sorts either by trending (number of stars on github) or recent
Dropdown for selecting sort method.

Empty state –
Text saying no projects found.

***Settings Page***
Vertical list of buttons aligned to the left.

Account –
Option to log out, and delete account

Billing –
Saved cards
If no saved cards -> text saying no saved cards
Option to remove card

***Project Detail Page***
Whether it is stopped or active is stored in the database. All project information stored in the database.
Stopped state –
Project details on the left (project name, status, created date, repository url, elapsed time, cost, progress)
Resume button bottom left
History on the right
Scroll view with entries in order for project creation, message sent, project stopped, project resumed
If no history simply displays text saying project not started.
More options button in top right. When clicked -> modal opens with delete button.
When the delete button clicked -> confirmation pop up.

Active state –
Project details on the left (project name, status, created date, repository url, elapsed time, cost, progress)
Elapsed time, cost, and progress are live values updated as the project goes on.
Stop button bottom left
Chat/history on right
Same scroll view as history with messages sent and project state changes. Messages from the AI agent/project will only either be status updates (project started, stopped, etc.) or request for information (Api keys, usernames, etc.). Text field for entering a message, send button at bottom of scroll view.

***Projects Page***
Grid of project cards
Vertical scroll view
Cards have hover effect to indicate they are clickable
When clicked -> project detail view is opened for that project

Active state –
Cards contain project details with stop button on bottom and elapsed time and cost next to stop button.

Stopped state –
Cards contain project details with elapsed time and cost on bottom.

Empty state –
Text saying you have no projects.
Button to create a new project.

***New Project Page***
Card centered on screen.
Description label
Description text field
Max runtime label
Number enter field for entering max runtime in hours (optional for user)
Budget label with tooltip (need to note: external API use not counted in budget calculation)
Number enter field for entering max cost (optional for user)

GitHub Repositories
[Add New Repository Button][Add Existing Repository Button]
List of added repositories (initially empty)
Repository 1: (New Repository)
[text field:"Repository Name" (for New Repo)]
[text field:”Organization name” (Optional)]
[check box:”Private” (false by default)]
[delete button]
Repository 2: (dynamically added as user clicks "Add Repository") (Existing Repository)
[text field: "GitHub Repository URL" (for Existing Repo)
If no repositories are added, display a note: "No repository provided, new one’s will be automatically created on your account."

Cost
Detect device type (if mobile or old device, fallback to simple string search)
Otherwise:
Lazy load [transformers.js](http://transformers.js) model in background when new project page is opened. (cached)
Estimate cost whenever the user stops typing in the description text field. (send description to model, ask for duration, and provide examples)

Estimated cost label with total. When clicked, the calculation breakdown expands below.
Calculation:
Estimated completion time, clamped by user’s entered max runtime. (Show a warning if clamped)
Flat rate (same for all projects) * completion time
Average hourly AI api cost * completion time (Show a disclaimer if user provided their own API keys for any of the models)
Show full equation.

Start button.

Advanced options dropdown–
Expands more options below in same card
Contains options for selecting models for different levels of intelligence. (utility, low, medium, high, super, backup) (can be the same model for any number of them) (drop down for company name, text box for model name)
Secure input fields (masked) for providing Api keys (different key for each intelligence level)
If the user provided a key for the provider, it automatically shows it as protected. There should be no way to actually read it.
Installations section with add button to add new installation
Each installation is a dropdown with options for programming languages, github repo, or other.
Add button for each level of intelligence. When clicked adds another model to that intelligence level. There can be any number of models for each intelligence level. (The backend will alternate using them to increase rate limits)
Utility [+]
[model select] [Api key]
Low [+]
[model select] [Api key]
Medium [+]
[model select] [Api key]
High [+]
[model select] [Api key]
Super [+]
[model select] [Api key]
Backup [+]
[model select] [Api key]

Option to link Jira account

***Login Page***
Github Oauth is the only way to login, so present just that option. Should have an explanation of what github is and how it will be used. (e.g. explain that a repository will be created on their account and the software will be pushed to it.)
The front end should handle the Github Oath and send the resulting information to the backend for storage.

***Tutorial***
After logging in tutorial starts
Click through popups that hover over each element. Goes through how to add funds, watch ads, explore page, projects page, then how to create their first project. Once complete, ask if you are familiar with github. If yes shows github information with links and images. Once complete or if no, shows tutorial complete popup with add funds instruction and button.

***Header***
Blue Banner (dismissible): "This website was created from a single prompt!"
If a banner has been dismissed before when a user opens the website, the next banner should show if there is one. For example: “Open source coming soon!”

***Flow***
Present the main page first always. If the user clicks the ad balance or watch ad button and they aren’t signed in, the login page should pop up. Also, if the user is not signed in, the account button dropdown should have only a sign in button.

***Accessibility***
Semantic HTML, ARIA roles, keyboard navigation, color contrast

***Responsive Design***
Needs to be responsive and work well on different screen sizes (desktop, tablet, mobile).

***Polling Strategy & UI Feedback***

Frontend needs to implement this polling mechanism after start/stop requests.

Poll every minute. Simply update values. No UI feedback for polling needed.

***Loading States***
Loading indicators (spinners, skeletons) whenever data is being fetched (e.g., loading projects, project details, settings) or actions are being processed (e.g., creating/starting/stopping projects, sending messages).

***Jira integration (optional per project)***
Authorization Request –
Add a “Link Jira Account” button on your website that redirects users to Atlassian’s authorization endpoint (e.g., `https://auth.atlassian.com/authorize`) with the appropriate query parameters (client\_id, redirect\_uri, scopes, etc.).

User Consent –
The user will be prompted to grant permission for your application to access their Jira data.

Token Exchange –
Once the user authorizes your app, Atlassian will redirect back to your specified callback URL with an authorization code. Your backend then exchanges this code for an access token (and possibly a refresh token) by calling Atlassian’s token endpoint (e.g., `https://auth.atlassian.com/oauth/token`).

***Firebase Notifications –***

This /notifications page/component needs to:

1. Initialize Firebase Cloud Messaging (FCM) and request permission for notifications.
2. Get the FCM token and send it to the backend\'s /notifications/register API endpoint to subscribe the user to notifications.
3. Handle incoming notifications:
   * Display notifications when the app is in the foreground using Firebase\'s onMessage callback.
   * When the app is in the background, Firebase will automatically display notifications.

Notification Handling

* When a notification is received, display it to the user with a relevant message.
* Optionally, provide a button to redirect the user to a specific page or settings.

**Core Concepts for the Frontend Team:**

1. **Base URL:** All API calls will be made to the base URL where the management layer is exposed (e.g., https://api.prompttosoftware.com/api/v1). This will be provided by the infrastructure team.
2. **Authentication:**
   * Most endpoints require authentication. Users will authenticate via GitHub OAuth.
   * The backend will provide a **JSON Web Token (JWT)** after successful authentication.
   * The frontend must send this JWT in the Authorization header for all protected requests: Authorization: Bearer \<YOUR\_JWT\_TOKEN\>.
   * If a request is made to a protected endpoint without a valid JWT, the backend will respond with a 401 Unauthorized error.
3. **Content-Type:** For requests with a body (POST, PUT, PATCH), the frontend must send the Content-Type: application/json header.
4. **Error Handling:** The backend will use standard HTTP status codes. Expect responses like:
   * 200 OK: Successful GET, PUT, PATCH.
   * 201 Created: Successful POST that created a resource.
   * 202 Accepted: Request accepted for processing, but not yet complete (e.g., starting a project).
   * 204 No Content: Successful DELETE.
   * 400 Bad Request: Invalid input data (check response body for details, often an array of validation errors).
   * 401 Unauthorized: Missing or invalid JWT.
   * 403 Forbidden: Authenticated user does not have permission for the action.
   * 404 Not Found: Resource not found.
   * 409 Conflict: Conflict, e.g., trying to create a resource that already exists.
   * 500 Internal Server Error: Something went wrong on the backend.
   * Error responses will typically include a JSON body like: { "status": "error" or "fail", "message": "Error description", "details": [...] }.
5. **Asynchronous Operations:** Actions like starting/stopping projects are asynchronous. The API will immediately return a 202 Accepted status. The frontend will need to poll the project status endpoint to get updates on the actual status change (starting -> running, stopping -> stopped).
6. **Live Data (Elapsed Time/Cost):** These values are calculated and updated by the backend. The frontend should fetch them via the project detail or status endpoints. The backend will handle the calculation based on the project's active time and resource configuration.

---

### **Concise API Specification**

This document outlines the API endpoints for the web application. The focus is on the purpose and data flow of each endpoint, leaving the specific implementation details and schema validation to the development agent.

---

### **1. Authentication**

Handles user sign-up and session management via GitHub OAuth.

| Endpoint | Purpose | Auth | Request Body | Success Response |
| :---- | :---- | :---- | :---- | :---- |
| **POST /auth/github** | Exchanges a GitHub OAuth code for a session JWT. Creates a new user if one doesn\'t exist. | Public | code from GitHub redirect. | The user\'s profile object and the session token. |
| **GET /auth/me** | Fetches the full profile of the currently authenticated user. | JWT | None. | The complete user object, including sensitive fields like balance. |
| **POST /auth/logout** | Invalidates the user\'s session (optional, for stateful tokens). | JWT | None. | A success confirmation message. |

---

### **2. User Account**

Allows users to manage their account.

| Endpoint | Purpose | Auth | Request Body | Success Response |
| :---- | :---- | :---- | :---- | :---- |
| **DELETE /users/me** | Deletes the authenticated user\'s account and associated data. | JWT | None. | 204 No Content or a success message. |

---

### **3. Payments & Billing**

Manages user balance, payments via Stripe, and ad credits.

| Endpoint | Purpose | Auth | Request Body | Success Response |
| :---- | :---- | :---- | :---- | :---- |
| **POST /payments/create-intent** | Creates a Stripe Payment Intent to add funds to the user\'s balance. | JWT | amount(in cents). | A clientSecret to be used with the Stripe frontend SDK. |
| **POST /payments/stripe-webhook** | **[Backend Only]** Listens for events from Stripe to confirm payments and update user balances. | Stripe Sig. | Stripe event payload. | Varies based on Stripe event. |
| **GET /payments/cards** | Retrieves a list of the user\'s saved payment methods. | JWT | None. | A list of card objects (brand, last4, expiry). |
| **DELETE /payments/cards/{id}** | Deletes a saved payment method. | JWT | None. | 204 No Content or a success message. |
| **POST /ads/credit** | Credits the user\'s account after they have successfully watched an advertisement. | JWT | (Optional) Ad identifier. | The user\'s newBalance and the creditedAmount. |

---

### **4. Projects**

Core endpoints for creating, managing, and viewing user projects.

| Endpoint | Purpose | Auth | Request Body | Success Response |
| :---- | :---- | :---- | :---- | :---- |
| **POST /projects** | Creates a new project with specified settings. | JWT | Project name, description, and optional configuration fields. | 201 Created with the full new projectobject. |
| **GET /projects** | Lists all projects for the authenticated user. Supports pagination and filtering via query params. | JWT | None. | A paginated list of project summary objects. |
| **GET /projects/explore** | Fetches public or trending projects for the "Explore" page. | Public | None. | A list of public project summary objects. |
| **GET /projects/{id}** | Retrieves all details for a single project. | JWT | None. | The complete project object. |
| **DELETE /projects/{id}** | Deletes a specific project. | JWT | None. | 204 No Content or a success message. |
| **POST /projects/{id}/start** | Starts or resumes a stopped project. This is an asynchronous operation. | JWT | None. | 202 Accepted with a confirmation message. |
| **POST /projects/{id}/stop** | Stops a running project. This is an asynchronous operation. | JWT | None. | 202 Accepted with a confirmation message. |
| **GET /projects/{id}/status** | A pollable endpoint to get a project\'s live status, cost, and other real-time metrics. | JWT | None. | An object with the current status, cost, elapsedTime, etc. |

---

### **5. Project Communication**

Endpoints for interaction between the user and the agent within a project.

| Endpoint | Purpose | Auth | Request Body | Success Response |
| :---- | :---- | :---- | :---- | :---- |
| **POST /projects/{id}/messages** | Sends a message from the user to the project\'s agent. | JWT | The message content. | A success confirmation message. |
| **GET /projects/{id}/history** | Retrieves the full chronological history of events and messages for a project. | JWT | None. | An array of history items (messages, events, agent requests). |
| **POST /projects/{id}/response-sensitive** | Allows the user to approve or deny an agent\'s request for sensitive information (e.g., API keys). | JWT | requestId, approvedstatus, and the requested data (if approved). | A success confirmation message. |
```

### Project Scope:
The project scope is limited to the development of the frontend web application for PromptToSoftware. This includes all specified UI pages, persistent elements, pop-ups, and interactions, with a strong focus on responsiveness, accessibility, and integration with the defined backend API. The project explicitly excludes backend development, although knowledge of backend interactions is critical for frontend design.

### User Goals & Success Criteria:
*   **Seamless User Experience:** Intuitive and responsive interface across devices.
*   **Efficient Project Management:** Users can easily create, manage, and monitor their software development projects.
*   **Transparent Billing:** Clear display of balance and project costs, with easy fund addition.
*   **Secure & Reliable Interactions:** Confident handling of personal and payment information.
*   **Effective Communication:** Users can interact with agents when necessary and receive timely updates.
*   **Accessibility:** Usable by individuals with diverse needs.
*   **Completeness:** All specified pages, features, and interactions are fully implemented.

### Constraints & Preferences:
*   **Frontend Only:** No backend development or cloud deployment by this agent.
*   **Backend Integration:** Frontend must align with the provided API specification. Assumption: Backend will adapt to frontend needs if information is missing.
*   **Theme:** Minimalist, white, black, gray. Utilizes Stripe UI components.
*   **Authentication:** GitHub OAuth only.
*   **Payments:** Stripe integration.
*   **Ad Integration:** Google Adsense with specific functionality for crediting balance.
*   **ML Model:** `transformers.js` to be lazy-loaded for cost estimation.
*   **Notifications:** Firebase Cloud Messaging.
*   **Polling:** 1-minute interval for project status, no UI feedback for polling itself.
*   **Development Environment:** Headless Docker container, no cloud credentials, no nested Docker execution. Local testing and verification only.

### Technical Context:
*   Existing API specification provided.
*   Backend handles user authentication (JWT), payments (Stripe webhooks), project logic, and data storage (MongoDB).
*   Firebase notifications managed by the backend (registration, handling foreground/background notifications on frontend).
*   `transformers.js` model for client-side cost estimation on the "New Project" page.

---

## 2. Enhanced Requirements Specification

### Functional Requirements:
*   **Authentication & Authorization:**
    *   User login via GitHub OAuth.
    *   JWT management (storage, sending with requests, handling expiry/401s).
    *   Session management, including logout and account deletion.
    *   Protected routes and UI elements based on authentication status.
*   **Account & Payments:**
    *   Display current account balance persistently.
    *   Feature to add funds via Stripe (modal with amount, Stripe Elements, error display).
    *   Ability to view and remove saved payment cards.
    *   "Watch ad" functionality to credit account balance (Google Adsense integration).
*   **Project Management:**
    *   **New Project:** Form for project description, max runtime, budget. GitHub repository selection (new/existing). Client-side cost estimation using `transformers.js` with detailed breakdown. Advanced options for AI model selection and API key input. Jira account linking.
    *   **Dashboard:** Central hub displaying active projects with key info (repo, cost, runtime, progress), account-wide usage (spending graph, budget prediction), and add funds button.
    *   **Projects Page:** Grid display of all projects (active/stopped) with hover effects. Navigation to project details. Empty state handling.
    *   **Project Detail Page:** Display comprehensive project details (status, dates, URLs, live elapsed time/cost/progress). State-dependent UI (stop/resume button). Integrated chat/history view with message sending and sensitive info request handling. Project deletion via a confirmation modal.
    *   **Explore Projects:** Search bar, sort options (trending/recent), grid display of public projects, empty state.
*   **Navigation & Layout:**
    *   Persistent side navigation bar (expandable/collapsible) with tooltips.
    *   Persistent profile, balance, add payment, watch ad buttons.
    *   Page title.
    *   Dynamic header banners.
*   **User Support & Information:**
    *   Help page with sections on About, GitHub, Jira, Addons, Billing.
    *   Tutorial for first-time users post-login.
*   **System Interactions:**
    *   Polling mechanism for live project status updates.
    *   Centralized error display modal with auto-close.
    *   Loading indicators for all data fetching and action processing.
    *   Firebase notifications initialization and handling for foreground/background.

### Non-Functional Requirements:
*   **Performance:**
    *   Fast initial load times (e.g., SSR/SSG with Next.js).
    *   Optimized asset loading (lazy loading for images, `transformers.js` model).
    *   Efficient state management to prevent unnecessary re-renders.
    *   Response times for UI updates to user actions should be ~100ms.
*   **Scalability (Frontend):**
    *   Component-based architecture allowing for modular development and reusability.
    *   Scalable state management.
    *   Maintainable codebase for future feature additions.
*   **Security:**
    *   **JWT Handling:** Store JWT securely (e.g., in HttpOnly cookies if backend supports, otherwise local storage with XSS prevention measures). Use `Bearer` token in headers.
    *   **Input Validation:** Client-side validation for all user inputs before API submission.
    *   **Sensitive Data:** Mask API keys and sensitive information displayed in UI. Handle `pendingSensitiveRequest` securely.
    *   **XSS/CSRF Prevention:** Sanitize user-generated content, use anti-CSRF tokens if applicable (backend responsibility but frontend should send).
    *   **Dependency Security:** Regular security audits of third-party libraries.
    *   **Stripe Integration:** Strictly adhere to Stripe.js and Stripe Elements best practices for card data handling (PCI compliance).
*   **Reliability:**
    *   Robust error handling (centralized, user-friendly messages for API errors).
    *   Fallback mechanisms for external integrations (e.g., `transformers.js` model loading failure).
    *   Graceful degradation for network issues.
*   **Usability & Accessibility:**
    *   **Responsive Design:** Optimal experience across desktop, tablet, and mobile (breakpoints handled).
    *   **Accessibility (A11y):** Semantic HTML, ARIA roles, keyboard navigation, sufficient color contrast, focus management.
    *   **Loading States:** Comprehensive use of spinners, skeletons, or disabled states.
    *   **Empty States:** User-friendly messages and actions for empty data sets.
*   **Maintainability:**
    *   Clean code architecture, consistent coding standards.
    *   Comprehensive documentation (component props, state flow).
    *   Modular design for easy debugging and future enhancements.

### Production-Grade Enhancements:
*   **Monitoring & Analytics:** Integrate with a client-side analytics tool (e.g., Google Analytics, though not explicitly requested, essential for production) to track user behavior and performance metrics. Implement error tracking (e.g., Sentry equivalent for local simulation).
*   **Internationalization (i18n):** While not explicitly requested, plan for i18n readiness to support future localization, structuring text content for easy translation.
*   **Caching Strategy:** Implement client-side caching for API responses (e.g., React Query/SWR) to improve perceived performance and reduce unnecessary network requests.
*   **Offline Support:** Evaluate and potentially implement basic offline capabilities using Service Workers for core static assets.
*   **Design System:** Establish a clear design system for UI components to ensure consistency and accelerate development.

### Compliance & Security:
*   **GDPR/Privacy:** Acknowledge data privacy requirements, especially around user data, payments, and notifications. Frontend must respect user consent for notifications and analytics.
*   **PCI DSS:** Strict adherence to Stripe's guidelines for payment processing. No raw card data handled by the frontend.
*   **Security Headers:** Recommend proper HTTP security headers (CSP, HSTS etc.) for deployment, even if not implemented by the agent.
*   **Rate Limiting:** Implement client-side debouncing/throttling for high-frequency input events (e.g., cost estimation) to reduce unnecessary backend calls.

### SLA/SLO Definitions (Conceptual for Frontend):
*   **Availability:** UI components must render without error 99.9% of the time (client-side availability).
*   **Page Load Time:** First Contentful Paint (FCP) < 1.5 seconds, Largest Contentful Paint (LCP) < 2.5 seconds on desktop/modern mobile devices.
*   **Responsiveness:** Interaction to Next Paint (INP) < 200 milliseconds.
*   **API Response Handling:** UI should update within 300ms of receiving a valid API response.
*   **Error Rate:** Client-side errors (e.g., uncaught JavaScript exceptions) should be below 0.1% of page views.

---

## 3. Technical Architecture & Design

### System Architecture:
The frontend will be developed as a Single Page Application (SPA), enhanced with Server-Side Rendering (SSR) capabilities using a framework like Next.js for improved performance and SEO. The architecture will be component-driven, promoting reusability and maintainability.

```
+--------------------+        +---------------------+        +--------------------+
|      User Web      |        |   PromptToSoftware  |        |      Backend       |
|      Browser       |        |   Frontend (SPA)    |        |        APIs        |
| (Desktop/Tablet/   |<------->(React/Next.js App)  |<------> (RESTful Endpoints)|
|      Mobile)       |        |                     |        |  (API Spec)        |
+--------------------+        +---------------------+        +--------------------+
        ^ ^ ^                   |        ^ ^                  | ^ ^ ^ ^
        | | |                   |        | |                  | | | | |
        | | |                   |        | |                  | | | | |
        | | +-------------------+--------+ |                  | | | | |
        | |   Static Assets (HTML, CSS, JS, Images)           | | | | |
        | +-----------------------------------------------------| | | |
        |         Server-Side Rendering (Initial Page Load)     | | | |
        +---------------------------------------------------------+ | |
                  Client-Side Interactions (JS, DOM updates)        | |
                                                                    | |
+-----------------------------------------------------------------+ |
|                   External Services (via Frontend direct calls where applicable)
|                                                                 |
|  +-------------------+  +-------------------+  +-------------------+
|  | Stripe.js         |  | Google Adsense    |  | Firebase SDK (FCM)|
|  | (Payment UI)      |<->| (Ad Display)      |  | (Notifications)   |
|  +-------------------+  +-------------------+  +-------------------+
|                                                                 ^
|                                                                 |
|  +-------------------+  +-------------------+  +-------------------+
|  | GitHub OAuth      |  | transformers.js   |  | Atlassian/Jira    |
|  | (Auth Redirect)   |  | (Cost Estimation) |  | (OAuth Redirect)  |
|  +-------------------+  +-------------------+  +-------------------+
+-----------------------------------------------------------------------------------
```

### Technology Stack:
*   **Frontend Framework:** React.js (via Next.js)
*   **Language:** TypeScript
*   **State Management:** React Context API or Zustand (for simpler global state) / Redux Toolkit (if complexity demands). Prefer simpler options first.
*   **Styling:** Tailwind CSS (utility-first CSS framework) for rapid UI development and customization. Possibly integrated with a headless UI library (e.g., Radix UI, Headless UI) for accessible components.
*   **UI Components:** Custom components built with Tailwind CSS. For Stripe UI components, directly integrate [Stripe Elements](https://stripe.com/docs/elements).
*   **HTTP Client:** `axios` (for robust API interaction, interceptors, error handling) or native `fetch` API for simpler cases.
*   **Routing:** Next.js built-in file-system based routing.
*   **Form Management:** React Hook Form or Formik for efficient form handling and validation.
*   **Local Storage/Caching:** React Query / SWR for server state management and caching.
*   **ML Model on Frontend:** `transformers.js` (Hugging Face) for client-side AI cost estimation model.
*   **Notifications:** Firebase JavaScript SDK.
*   **Charting:** Recharts or Chart.js for usage graphs.
*   **Date Management:** `date-fns` or `moment.js` (if legacy needed) for date formatting and manipulation.
*   **Testing Frameworks:**
    *   Unit/Integration: Jest, React Testing Library
    *   E2E: Playwright or Cypress (for local simulation)
*   **Linting/Formatting:** ESLint, Prettier
*   **Bundler:** Webpack (underlying Next.js)

### Data Architecture (Frontend Perspective):
*   **Client-Side State:**
    *   **Global State:** User authentication status (JWT), current balance, theme settings, application-wide banners. Managed by Context API or Zustand.
    *   **Page/Component Local State:** Form inputs, loading states, modal visibility, project-specific details. Managed by `useState`, `useReducer`.
    *   **Server State (Cached Data):** Projects list, project details, user profile, saved cards. Managed by React Query/SWR for intelligent caching, revalidation, and synchronization.
*   **Data Flow:**
    1.  User interaction triggers an action.
    2.  Action dispatches to state management or directly to API client.
    3.  API client makes HTTP request with JWT.
    4.  Backend responds with data or error.
    5.  API client processes response, updates relevant local/cached state.
    6.  UI re-renders based on state changes.
    7.  Polling mechanism periodically fetches and updates project statuses, ensuring live data.

### Security Architecture (Frontend):
*   **Authentication Token Storage:** While backend might provide HttpOnly cookies, if JWT needs to be accessed by JS, it will be stored in `localStorage`. This requires strong XSS protection (Content Security Policy, input sanitization). Refresh tokens handled securely by backend.
*   **API Key Handling:** Masked input fields for API keys. Frontend *never* stores these keys unencrypted or makes them directly available for reading. They are sent *once* to the backend upon submission.
*   **Stripe Integration:** Use Stripe.js and Elements, which securely collect sensitive payment information without it ever touching the frontend servers. Client secret from `create-intent` is used solely for the Stripe SDK.
*   **Input Sanitization:** Sanitize all user-generated content (e.g., project descriptions, chat messages) before displaying on the UI to prevent XSS attacks.
*   **Content Security Policy (CSP):** Recommend strict CSP headers from the web server to mitigate XSS and data injection attacks by restricting resources the browser is allowed to load.
*   **`HTTPS`:** All API communications will occur over HTTPS. (Implicit as per API Base URL)
*   **Error Disclosure:** Configure the frontend to display generic error messages to users, logging detailed errors only to logging/monitoring systems (not directly to user UI).

### Integration Points:
*   **PromptToSoftware Backend API (REST):**
    *   Authentication (`/auth/*`), User Account (`/users/me`), Payments (`/payments/*`, `/ads/credit`), Projects (`/projects/*`), Project Communication (`/projects/{id}/messages`, `/projects/{id}/history`, `/projects/{id}/response-sensitive`).
    *   All requests require `Authorization: Bearer <JWT>`.
    *   `Content-Type: application/json` for requests with bodies.
*   **GitHub OAuth:** Frontend initiates redirect to GitHub, handles callback, sends `code` to backend endpoint POST `/auth/github`.
*   **Stripe.js & Stripe Elements:** Client-side SDKs for secure payment form rendering and tokenization.
*   **Google Adsense:** Direct integration for ad display and tracking.
*   **Firebase Cloud Messaging (FCM):** Client-side SDK for registering device token and receiving/displaying notifications.
*   **`transformers.js`:** Loaded as a JavaScript module for local inference.
*   **Jira OAuth:** Frontend initiates redirect to Atlassian, handles callback, sends `code` to backend for token exchange.

### Scalability Design (Frontend):
*   **Component Reusability:** Design atomic components (buttons, inputs, modals) and compose them into complex features.
*   **Code Splitting/Lazy Loading:** Utilize Next.js's automatic code splitting and dynamic imports for routes and large dependencies (e.g., `transformers.js`, charting libraries) to reduce initial bundle size.
*   **SSR/SSG:** Leverage Next.js for server-side rendering of initial page loads and static site generation for static content (e.g., Help, About pages) to improve performance and reduce server load on the backend.
*   **Performance Budgeting:** Tools like Lighthouse CI used in CI/CD (conceptual for local) to monitor performance metrics.
*   **Caching:** Use browser caching for static assets and React Query/SWR for client-side data caching, reducing repetitive API calls.

### Local Verification Strategy:
Given the development environment constraints (headless Docker, no cloud, no nested Docker execution), local verification will rely heavily on:

1.  **Strict Unit Testing:** Test individual functions, components in isolation.
2.  **Mocking & Stubbing:**
    *   **API Calls:** Use tools like [Mock Service Worker (MSW)](https://mswjs.io/) to intercept all outgoing HTTP requests and return predefined mock responses. This allows simulating all backend API interactions (success, error, loading states for all specified endpoints) without a live backend.
    *   **External SDKs:** Mock Firebase, Stripe.js, Google Adsense, `transformers.js` (including its model loading) to return predictable values or simulate their behavior.
    *   **Browser APIs:** Mock `localStorage`, `window.location`, `navigator` (for device type detection).
3.  **Local Development Server:** Run the Next.js development server locally.
4.  **Configuration Simulation:** Use environment variables (.env files) to simulate different configurations (e.g., `NEXT_PUBLIC_API_BASE_URL` pointing to `localhost:3000` where MSW runs).
5.  **Dockerfile & docker-compose.yml Validation:**
    *   **Syntax Check:** Use linters (e.g., `hadolint`) for Dockerfile syntax.
    *   **Content Validation:** Write unit tests (e.g., Node.js scripts in `tests` folder) that parse the Dockerfile/docker-compose.yml files and assert content, exposed ports, volume mounts, build arguments, ensuring they align with expected deployment configurations. These tests run within the development container.
6.  **Cloud Service Interface Tests (Mocked):** Create distinct test suites that specifically target the interaction points with cloud services.
    *   **Firebase SDK:** Mock `firebase/app`, `firebase/messaging` modules to simulate token registration, message receipt, and permission requests.
    *   **Stripe SDK:** Mock `Stripe.js` and `Elements` to simulate `createPaymentMethod`, `confirmCardPayment` calls, and `clientSecret` handling.
    *   These mocks allow verification of frontend logic interacting with cloud services without making actual calls or needing credentials.
7.  **Screencasting/Headless Browser Automation:** For "visual" checks like responsive design or tutorial flow, use a headless browser (e.g., Playwright, Puppeteer) to capture screenshots or record videos within the container, which can then be validated or manually reviewed. This provides a visual verification even without a GUI.

---

## 4. Detailed Implementation Plan

### Development Phases:

1.  **Phase 1: Foundation & Core Setup ( approx. 2 weeks)**
    *   Project Setup: Next.js with TypeScript, ESLint, Prettier, Tailwind CSS.
    *   Basic Layout: Responsive header, side nav bar, profile/balance buttons, page title structure.
    *   Routing: Implement basic routing for all specified pages (placeholder components).
    *   Authentication Core: Implement GitHub OAuth flow (redirect, callback handling, JWT storage), mock API for login/logout/`auth/me`.
    *   Global State: User authentication, balance, and general application context.
    *   Error & Loading States: Implement generic error modal and loading component.
    *   Initial Accessibility & Responsiveness: Base styles and media queries.
    *   API Client Setup: `axios` or `fetch` wrapper with JWT interceptor, error handling.
    *   MSW Setup: Configure Mock Service Worker for comprehensive API mocking.

2.  **Phase 2: Account & Payments (approx. 2 weeks)**
    *   Balance Display: Integrate with mocked `/auth/me` endpoint.
    *   Add Funds Modal: Stripe Elements integration, mocked `payments/create-intent`.
    *   Saved Cards: Display and delete functionality, mocked `/payments/cards` and `/payments/cards/{id}`.
    *   Watch Ad Functionality: Google Adsense placeholder, mocked `/ads/credit`.
    *   Settings Page: Account (logout, delete), Billing (saved cards).

3.  **Phase 3: Project Creation & Overview (approx. 3 weeks)**
    *   New Project Page:
        *   Form UI (description, runtime, budget).
        *   GitHub Repositories: Add new/existing logic, display list.
        *   Cost Estimation: `transformers.js` lazy loading, device type detection, string search fallback. Integrate with mocked model output and backend cost estimation API. Display breakdown.
        *   Advanced Options: UI for AI model selection, masked API key inputs, installations, Jira linking (frontend button flow).
    *   Dashboard:
        *   Active Projects Summary: Display basic info for active projects via mocked `/projects`.
        *   Usage Information: Placeholder for graphs, budget prediction.
        *   Add Funds button.
    *   Projects Page: Grid and list view for projects, mocked `/projects`. Empty state & "Create New Project" button.

4.  **Phase 4: Project Details & Interactions (approx. 3 weeks)**
    *   Project Detail Page:
        *   Display details (status, created date, repo URL, elapsed time, cost, progress).
        *   Live data polling (`/projects/{id}/status`).
        *   Start/Stop functionality (mocked `/projects/{id}/start`, `/projects/{id}/stop`).
        *   History/Chat: Display mocked `/projects/{id}/history`, message input and sending (`/projects/{id}/messages`).
        *   Sensitive Information Request Popup: Display and interaction for `/projects/{id}/response-sensitive`.
        *   Delete Project: Confirmation modal and mocked `/projects/{id}` DELETE.

5.  **Phase 5: Public Pages & User Guidance (approx. 2 weeks)**
    *   Explore Projects Page: Search, sort, grid display, mocked `/projects/explore`.
    *   Help Page: All specified sections.
    *   Login Page: Dedicated `Github OAuth` prompt.
    *   Tutorial: Step-by-step pop-ups logic, GitHub info.
    *   Header Banners: Dismissible banner logic.

6.  **Phase 6: Notifications & Refinements (approx. 1 week)**
    *   Firebase Notifications: Initialize FCM, request permission, register token with mocked backend endpoint, handle incoming messages.
    *   Comprehensive loading states and empty states across all pages.
    *   Polish UI/UX, animations, transitions.
    *   Full accessibility audit and remediation.
    *   Cross-browser compatibility checks (simulated via headless browser).
    *   Final documentation updates.

### Component Breakdown:

*   **Layout Components:** `Header`, `SideNavBar`, `PageTitle`, `LayoutWrapper`.
*   **Global UI Components:** `ErrorModal`, `LoadingSpinner`, `SkeletonLoader`, `ConfirmationModal`, `PaymentModal`, `SensitiveInfoRequestModal`.
*   **Authentication Components:** `LoginButton`, `ProfileMenu`, `GitHubLoginIntro`.
*   **Account/Billing Components:** `BalanceDisplay`, `AddFundsButton`, `WatchAdButton`, `SavedCardsList`, `CardItem`.
*   **Project Components:**
    *   `NewProjectForm` (with sub-components for repositories, cost estimation, advanced options).
    *   `ProjectCard`, `ProjectList/Grid`.
    *   `ProjectDetailsPanel`, `ProjectHistory/Chat`, `MessageInput`.
*   **Navigation Components:** `NavLink`, `ExpandCollapseButton`.
*   **Utility Components/Hooks:** `useAuth`, `usePolling`, `useFormValidation`, `useOutsideClick`, `LazyLoadModel`.
*   **Page Components:** `HomePage (Dashboard)`, `CreateProjectPage`, `ProjectsPage`, `ProjectDetailPage`, `ExplorePage`, `HelpPage`, `SettingsPage`, `LoginPage`.

### Dependency Management:
*   Utilize `npm` or `yarn` for package management.
*   Dependencies will be installed and managed through `package.json`.
*   Semantic versioning will be followed for all dependencies.
*   Regular dependency updates to address security vulnerabilities and leverage new features.

### Code Organization:

```
project/
├── public/                 # Static assets (images, fonts, etc.)
├── src/
│   ├── app/                # Next.js App Router root layout and pages
│   │   ├── (auth)/         # Grouped auth routes (login, callback)
│   │   │   ├── login/
│   │   │   └── page.tsx
│   │   ├── (main)/         # Grouped main app routes (dashboard, projects, settings)
│   │   │   ├── dashboard/
│   │   │   │   └── page.tsx
│   │   │   ├── projects/
│   │   │   │   ├── [projectId]/ # Dynamic route for project detail
│   │   │   │   │   ├── page.tsx
│   │   │   │   │   └── components/ # Project Detail specific components
│   │   │   │   ├── new/
│   │   │   │   │   └── page.tsx
│   │   │   │   └── page.tsx  # Projects list page
│   │   │   ├── explore/
│   │   │   │   └── page.tsx
│   │   │   ├── help/
│   │   │   │   └── page.tsx
│   │   │   ├── settings/
│   │   │   │   └── page.tsx
│   │   │   └── layout.tsx  # Shared layout for main app routes (nav, header)
│   │   ├── api/ # Next.js API Routes (if any server-side logic needed, not for backend interaction)
│   │   ├── layout.tsx      # Root layout for entire app
│   │   └── page.tsx        # Home/Dashboard page
│   ├── components/         # Reusable UI components (atomic, molecules, organisms)
│   │   ├── common/         # Buttons, inputs, modals, loading indicators
│   │   ├── layout/         # Header, SideNavBar, PageTitle
│   │   ├── auth/           # Login form, profile menu
│   │   ├── projects/       # ProjectCard, ProjectForm elements
│   │   └── utils/          # Generic UI utilities
│   ├── hooks/              # Custom React hooks (useAuth, usePolling, useForm)
│   ├── lib/                # Utility functions (API client, constants, helpers)
│   │   ├── api/            # API client setup, API call wrappers
│   │   ├── constants.ts
│   │   ├── auth.ts         # JWT handling utilities
│   │   ├── forms.ts        # Form validation schemas
│   │   └── models/         # TypeScript interfaces/types for API responses/data models
│   ├── styles/             # Tailwind CSS configuration, global styles
│   │   ├── globals.css
│   │   └── tailwind.config.ts
│   ├── context/            # React Context providers (e.g., AuthContext, BalanceContext)
│   ├── services/           # Logic for interacting with external SDKs (Stripe, Firebase)
│   ├── tests/              # Separate folder for test utilities and mocks
│   │   └── msw/            # Mock Service Worker handlers
│   └── types/              # Global TypeScript types and interfaces
├── .env.example            # Example environment variables
├── .eslintrc.json          # ESLint configuration
├── .prettierrc             # Prettier configuration
├── next.config.mjs         # Next.js configuration
├── package.json
├── tsconfig.json           # TypeScript configuration
├── Dockerfile              # Containerization for local development environment
├── docker-compose.yml      # For local dev environment setup (even if not run by agent, configuration will be validated)
```

### Development Standards:
*   **Coding Conventions:** Adhere to ESLint and Prettier rules for consistent code style.
*   **TypeScript:** Strict type checking (`strict: true` in `tsconfig.json`). Define interfaces for all data structures (API responses, component props, state).
*   **Component Structure:** Follow atomic design principles (atoms, molecules, organisms, templates, pages). Components should be single-responsibility.
*   **Error Handling:** Centralized API error handling. Display user-friendly messages for common errors, log detailed errors.
*   **Performance:** Optimize component rendering, use `React.memo`, `useCallback`, `useMemo` where appropriate. Lazy load heavy assets.
*   **Accessibility:** All UI components must be built with accessibility in mind (semantic HTML, ARIA attributes, keyboard navigation).
*   **Documentation:** Clear function/component/hook JSDoc comments. READMEs for complex modules.
*   **Code Review:** (Conceptual for agent) All code changes undergo peer review.

### Configuration Management:
*   **Environment Variables:** Use `.env.local` for local development. Define `NEXT_PUBLIC_` prefixed variables for client-side access. Examples:
    *   `NEXT_PUBLIC_API_BASE_URL`
    *   `NEXT_PUBLIC_GITHUB_OAUTH_CLIENT_ID`
    *   `NEXT_PUBLIC_FIREBASE_API_KEY`, etc.
*   **Version Control:** Git as the version control system.
*   **Branches:** `main` (production-ready), `develop` (integration), feature branches.
*   **Docker:** `Dockerfile` and `docker-compose.yml` to define the consistent development environment within the container. These files will be linted and content-validated.

---

## 5. Comprehensive Testing Strategy

Testing will follow the specified hierarchy, emphasizing local verification due to environment constraints.

### 5.1 Testing Hierarchy (Implement in this order)

#### 1. Unit Tests - Foundation First
*   **Purpose:** Verify individual functions, components, and hooks in isolation. Focus on business logic and pure functions.
*   **Scope:**
    *   Utility functions (API client helpers, date formatters, form validators).
    *   Reducers (if using `useReducer` or Redux).
    *   Custom hooks (e.g., `usePolling`, `useAuth` - test their internal logic, not their side effects on UI).
    *   Simple, pure UI components (e.g., `Button`, `Input`) using snapshot testing or basic prop rendering checks.
    *   Cost calculation logic in `NewProjectForm` (mock `transformers.js` output).
*   **Tools:** Jest for test runner and assertion library, React Testing Library for component testing.
*   **Approach:**
    *   Test edge cases, happy paths, and error conditions for functions.
    *   Use `render` and `screen` from RTL for components to simulate user interaction and assert DOM output.
    *   Aim for high code coverage (~80% target for critical business logic).

#### 2. Infrastructure Testing - No Deployment Required (Local Only)
*   **Purpose:** Validate configuration, environment setup, and interface definitions without deploying or running actual external services.
*   **Scope:**
    *   **Configuration Validation:**
        *   Parse `.env.example` and ensure all required environment variables are documented.
        *   Develop scripts/tests to check `next.config.mjs` for correct asset handling, base URL, etc.
        *   Verify `tsconfig.json` and linting configurations.
    *   **Docker Configuration Tests:**
        *   Use `hadolint` (or similar linter within the container) to check `Dockerfile` syntax and best practices.
        *   Write Node.js scripts to programmatically parse `Dockerfile` and `docker-compose.yml` (e.g., using `docker-file-parser` or manual regex/string parsing) and assert:
            *   Correct base image (`node:lts-alpine`).
            *   `WORKDIR` is set.
            *   Dependencies are copied and installed correctly.
            *   Ports are exposed as expected (`3000`).
            *   Volumes are mounted correctly (for `node_modules` caching, source code).
            *   Entrypoint/command is correct for starting Next.js dev server.
            *   Checks for potential security risks (e.g., root user).
    *   **Cloud Service Interface Tests (Mocked SDKs):**
        *   Create test files that `import { messaging } from 'firebase/app'` (mocked `firebase/app` to return mocked `messaging` object) and assert that `messaging.getToken()`, `messaging.onMessage()` are called with correct parameters.
        *   Mock Stripe.js functions (`loadStripe`, `elements`, `createPaymentMethod`) to ensure the frontend calls them with the right arguments and handles their mock return values.
        *   Verify the structure of data sent to and expected from mocked backend API calls for Firebase registration, Stripe intents, etc.
    *   **Database Schema Tests (Frontend's View):**
        *   Write TypeScript interfaces (`.d.ts` files) for expected API request and response payloads for *every* endpoint in the API specification.
        *   Use Jest to ensure that mock API responses (from MSW) conform to these defined interfaces, effectively "testing" the frontend's understanding of the backend schema. This is crucial for catching early integration mismatches.

#### 3. Integration Tests - Local Simulation
*   **Purpose:** Verify interactions between multiple components and with mocked external services (APIs, SDKs). Focus on data flow and state changes.
*   **Scope:**
    *   **Component Interactions:** Test how parent components integrate child components (e.g., `NewProjectForm` interacting with `RepositoryInput`).
    *   **API Endpoint Interactions:**
        *   Use MSW to intercept actual HTTP requests made by the API client and return predefined mock responses (success, 401, 400, 500, empty list, etc.).
        *   Test login/logout flow, project creation, starting/stopping projects, adding funds, sending messages, sensitive info request flow.
        *   Verify UI rendering based on various API responses (data loaded, loading states, error messages displayed).
    *   **State Management:** Test how actions modify global state and how components react to these state changes.
    *   **Form Submission:** Test full form submission process, including client-side validation, API call, and UI updates upon success/failure.
    *   **Polling Logic:** Verify that the `usePolling` hook (or similar) correctly fetches data at set intervals and updates the UI without explicit user action.
*   **Tools:** Jest, React Testing Library, Mock Service Worker (MSW).
*   **Approach:**
    *   Render logical units of components (e.g., a whole page or a significant section) that encapsulate the interaction being tested.
    *   Use MSW to control the backend's responses, simulating various scenarios.
    *   Assert on DOM changes, network requests made, and state updates.

#### 4. End-to-End Tests - Critical User Journeys (Local Simulation)
*   **Purpose:** Simulate full user workflows to ensure the entire application works cohesively from a user's perspective.
*   **Scope:**
    *   User login -> navigate to dashboard -> create a new project -> view project details -> send a message.
    *   User login -> check balance -> add funds -> view saved cards.
    *   User login -> view projects -> start a stopped project -> stop an active project.
    *   User login -> explore projects -> apply filters/sort.
    *   Tutorial flow completion.
*   **Tools:** Playwright or Cypress (running in headless mode within the Docker container). These tools provide APIs to interact with the browser, simulate clicks, type text, and assert on UI elements. They will interact with the locally running Next.js dev server, which itself will be backed by MSW.
*   **Approach:**
    *   Run a local Next.js development server (e.g., `npm run dev`) that routes API calls through MSW.
    *   Launch a headless browser instance.
    *   Define scenarios that mimic real user interactions.
    *   Assert on visible text, element presence, navigation, and state changes.
    *   Keep scenarios focused on "critical" paths to maintain manageability and execution speed.

### 5.2 Testing Implementation Details

*   **Testing Framework Selection:**
    *   **Jest:** As the primary test runner for unit and integration tests.
    *   **React Testing Library (RTL):** For component and integration testing, promoting testing component behavior from a user's perspective.
    *   **Mock Service Worker (MSW):** For mocking HTTP requests at the network level, enabling realistic integration testing without a real backend.
    *   **Playwright / Cypress:** For E2E testing in a headless browser.

*   **Test Data Management:**
    *   **In-Memory/Static Mocks:** For unit tests, create simple JavaScript objects/arrays that represent data.
    *   **MSW Fixtures:** For integration and E2E tests, define comprehensive JSON response fixtures for all API endpoints in `src/tests/msw/data/`. These fixtures will represent various states (empty, success, error, loading).
    *   **Test Data Generators:** Use libraries like `fakerjs` or custom factories to generate dynamic, realistic test data when static fixtures are insufficient (e.g., for paginated lists of projects).
    *   **Cleanup:** Tests should be isolated and repeatable. Each test should preferably set up its own data and clean up any global state. MSW handlers can be reset between tests.

*   **Mocking Strategy:**
    *   **Network Level Mocking (MSW):** Primary strategy for API calls. MSW will intercept `fetch` and `axios` requests.
    *   **Module Mocking (Jest):** For third-party SDKs (Firebase, Stripe, Adsense) and complex internal modules. Use `jest.mock('module-name')` to replace modules with controlled implementations.
    *   **Function Mocking (Jest):** Use `jest.fn()` to spy on or replace functions within a module or component, asserting calls and return values.
    *   **Global Object Mocking:** Mock `window`, `document`, `navigator` properties and methods as needed for specific browser API interactions or device type detection.
    *   **Clarity:** It will be clearly documented what is being mocked and why for each test suite. Avoid "mocking too much" in integration tests; focus on testing the real code paths.

*   **Local Testing Environment:**
    *   The entire testing suite will run within the provided headless Docker container.
    *   **Node.js Environment:** Jest and other test runners will execute in the Node.js environment provided by the Docker image.
    *   **Browser Environment (Simulated):** React Testing Library simulates a DOM environment without a real browser.
    *   **Headless Browser (for E2E):** Playwright or Cypress will be installed within the Docker container and configured to run in headless mode. They will launch a virtual browser (e.g., Chromium) inside the container to execute E2E tests against the locally served Next.js application (which in turn uses MSW).
    *   **Configuration:** `.env.test` file will store test-specific environment configurations (e.g., pointing API calls to MSW's interceptor).

*   **Continuous Integration (CI):**
    *   Conceptual: All tests (unit, infra, integration, E2E) will be run automatically on every code commit to ensure code quality and prevent regressions.
    *   Commands: `npm test` will trigger a combined test run. Specific commands for individual test types (e.g., `npm test -- unit`, `npm test -- e2e`).
    *   Reporting: Test reports will be generated (e.g., Jest's JSON reporters, Playwright's HTML reports) for analysis.

---

## 6. Production Deployment & Operations (Conceptual for Agent)

While the agent cannot perform actual cloud deployment, the plan outlines the necessary considerations to ensure the frontend is ready for a production environment.

### Deployment Strategy:
*   **Build Process:** Next.js build (`next build`) generates optimized HTML, CSS, JavaScript, and static assets.
*   **Server-Side Rendering (SSR):** Next.js application capable of SSR will be deployed to a Node.js-compatible environment (e.g., Vercel, AWS Amplify, EC2 with PM2/nginx, Kubernetes).
*   **Static Asset Hosting:** Static assets (JS bundles, CSS, images) can be served from a Content Delivery Network (CDN) for performance.
*   **CI/CD Pipeline (Conceptual):** Automated pipeline for building, testing, and deploying the frontend to production environments upon successful code merge to `main`. This includes `npm ci` (clean install), `npm test`, `npm run build`.

### Infrastructure Requirements (Conceptual):
*   **Frontend Server:** Node.js runtime environment to serve the Next.js application (for SSR). Sufficient CPU and RAM to handle rendering load.
*   **Load Balancing:** For high traffic, a load balancer distributes requests across multiple frontend instances.
*   **CDN:** For caching static assets and reducing latency for global users.
*   **Web Application Firewall (WAF):** To protect against common web vulnerabilities (e.g., SQL injection, XSS – though mostly for backend, WAF can block malformed requests targeting frontend routes).

### Monitoring & Alerting:
*   **Performance Monitoring:** Tools like Google Lighthouse, WebPageTest, or commercial RUM (Real User Monitoring) solutions (e.g., Datadog, New Relic) to track Core Web Vitals (LCP, FID, CLS, INP) in production.
*   **Error Tracking:** Integrate with Sentry, Bugsnag, or similar to capture and report client-side JavaScript errors, network errors, and unhandled promise rejections.
*   **Application Health:** Monitor frontend server metrics (CPU, memory, request latency if SSR).
*   **Alerting:** Set up alerts for critical errors, performance degradation thresholds, and API unreachability.

### Logging Strategy:
*   **Client-Side Logging:** Use a structured logging library (e.g., combination of `console.log`/`error` with a production logging service) to capture frontend events, user interactions, and errors.
*   **Server-Side Logging (for SSR):** If SSR is enabled, server-side logs of the Node.js process.
*   **Log Management:** Centralize logs in a log management system (e.g., ELK Stack, Splunk, Datadog Logs) for analysis and debugging.
*   **Sensitive Data:** Ensure no sensitive user information (API keys, payment details) is logged.

### Backup & Recovery (Conceptual for Frontend):
*   **Codebase Backup:** Regular backups of the Git repository.
*   **Configuration Backup:** Version control `env` configurations and deployment scripts.

### Incident Response:
*   **Playbooks:** Defined procedures for diagnosing and resolving frontend-related issues (e.g., broken UI, API integration failures, performance degradation).
*   **Alert Escalation:** Clearly defined escalation paths for critical alerts.
*   **Rollback Plan:** Ability to quickly rollback to a previous stable version in case of critical production bugs.

### Maintenance Procedures:
*   **Dependency Updates:** Regular audits and updates of third-party libraries to patch security vulnerabilities and leverage improvements.
*   **Performance Audits:** Periodic performance testing and optimization.
*   **Security Scans:** Regular scans for frontend vulnerabilities.
*   **Accessibility Audits:** Regular checks to ensure continued accessibility compliance.
*   **Browser Compatibility:** Continuous testing across a range of browsers and devices.

---

## 7. Project Timeline & Milestones

This is a high-level estimation. Actual timelines may vary based on complexity, resources, and unforeseen challenges.

*   **Phase 1: Foundation & Core Setup (Weeks 1-2)**
    *   **Milestone:** Basic UI shell with responsive layout, authenticated routing, and generic error/loading states demonstrated with mocked data.
    *   **Deliverables:** Project repository initialized, core tech stack configured, basic navigation, mock authentication flow working.

*   **Phase 2: Account & Payments (Weeks 3-4)**
    *   **Milestone:** User balance display, Stripe payment modal, saved cards management, and "watch ad" functionality integrated (all with mock backend).
    *   **Deliverables:** Functioning payment flows, settings page billing section.

*   **Phase 3: Project Creation & Overview (Weeks 5-7)**
    *   **Milestone:** Complete "New Project" page (including cost estimation with `transformers.js` mocked), functional Dashboard, and Projects list page.
    *   **Deliverables:** Project creation form, dashboard summaries, project listing page.

*   **Phase 4: Project Details & Interactions (Weeks 8-10)**
    *   **Milestone:** Fully functional "Project Detail" page with live updates, chat/history, sensitive info requests, and project control (start/stop).
    *   **Deliverables:** Robust project detail view, communication features.

*   **Phase 5: Public Pages & User Guidance (Weeks 11-12)**
    *   **Milestone:** All public pages ("Explore", "Help", "Login") and the post-login tutorial implemented. Dynamic header banners.
    *   **Deliverables:** Informative and guidance pages, guided user onboarding.

*   **Phase 6: Notifications & Refinements (Week 13)**
    *   **Milestone:** Firebase notifications integrated, comprehensive loading/empty states, final polish, and accessibility/responsiveness checks.
    *   **Deliverables:** Production-ready frontend, comprehensive test coverage.

### Risk Assessment & Mitigation:
*   **API Instability/Breaking Changes:**
    *   **Mitigation:** Close collaboration with backend team. Use TypeScript interfaces for API contracts. Comprehensive MSW mocks to identify issues early. Backend must respond to frontend needs.
*   **`transformers.js` Performance/Bundle Size:**
    *   **Mitigation:** Lazy loading the model. Optimize model choice (smaller model if available). Implement fallback string search. Consider Web Workers for calculation to avoid main thread blocking.
*   **Third-Party SDK Integration Complexity (Stripe, Firebase, Google Adsense):**
    *   **Mitigation:** Follow official documentation meticulously. Use community best practices. Robust mocking during testing.
*   **Accessibility & Responsive Design Challenges:**
    *   **Mitigation:** Integrate accessibility tools (ESLint a11y plugins, axe-core) into development workflow. Regular manual audits. Utilize established UI frameworks (if any) or headless UI components.
*   **Local Development Environment Limitations:**
    *   **Mitigation:** Heavy reliance on mocking and comprehensive testing strategies outlined in Section 5. Regular validation of Docker configurations.
*   **Scope Creep:**
    *   **Mitigation:** Strict adherence to the `Project Scope` defined in Section 1. Any new requirements must go through a formal change request process.

### Resource Requirements:
*   **Team:** 1-2 Frontend Developers (depending on desired acceleration).
*   **Skills:** Expertise in React.js/Next.js, TypeScript, modern CSS (Tailwind), state management, API integration, testing (Jest, RTL, MSW, Playwright), performance optimization, accessibility. Experience with Stripe.js, Firebase SDK, and potentially `transformers.js` is a plus.
*   **Tools:**
    *   Code Editor (VS Code recommended with extensions for ESLint, Prettier, Tailwind CSS).
    *   Node.js (LTS), npm/yarn.
    *   Git.
    *   Docker Desktop (for consistent local environment, though not run by agent dynamically).

---

## 8. Documentation Requirements

Comprehensive documentation is vital for maintainability, onboarding, and operational efficiency.

### Technical Documentation:
*   **Architecture Document:** High-level overview of the frontend architecture (as in Section 3), component breakdown, data flow diagrams.
*   **API Documentation:** Detailed specification of frontend-to-backend API contracts, including request/response schemas (TypeScript interfaces).
*   **Module/Service Documentation:** README.md files in `src/lib`, `src/services`, `src/context`, explaining their purpose, public APIs, and how to use them.
*   **Configuration Guide:** Document all environment variables, their purpose, and setup instructions for different environments.
*   **Deployment Guide (Conceptual):** Step-by-step instructions for building and deploying the frontend application to a production server/CDN.

### User Documentation:
*   **In-App Tutorial:** As specified in the user request.
*   **Help Page Content:** All textual content and explanations for the "Help" page.
*   **Troubleshooting Guide (for users):** Common issues and solutions (e.g., what to do if a payment fails).

### Developer Documentation:
*   **Project README.md:**
    *   Project overview.
    *   Local setup instructions (pre-requisites, `docker-compose up`, `npm install`, `npm run dev`).
    *   Project structure explanation.
    *   Available `npm` scripts (build, test, lint, dev).
    *   Contribution guidelines (branching strategy, commit message conventions, code review process).
*   **Code Comments:** JSDoc comments for all functions, components, hooks, interfaces, detailing their purpose, parameters, return values, and any side effects.
*   **Testing Guide:** How to run different types of tests, how to create new tests, mocking strategies, and troubleshooting failing tests.

### Operations Documentation:
*   **Runbooks (Conceptual):** Step-by-step guides for common operational tasks related to the frontend (e.g., how to check frontend health, how to perform a rollback, how to clear client-side caches).
*   **Monitoring & Alerting Guide:** Explanation of key metrics, dashboard locations, and alert configurations for the frontend.
*   **Logging Standards:** Guidelines on what and how to log from the frontend, and how to access and interpret logs.
*   **Maintenance Schedule:** Recommended frequency for dependency updates, performance audits, and security scans.
